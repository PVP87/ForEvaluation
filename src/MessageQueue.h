#ifndef _MESSAGEQUEUE_H
#define _MESSAGEQUEUE_H

#include <mutex>
#include <deque>
#include <condition_variable>

template <typename T>
class MessageQueue
{
  public:
    T receive()
    {
        std::unique_lock<std::mutex> ulock(_mutex);
        _cond.wait(ulock, [this]{ return !_messages.empty(); });
        T msg = std::move(_messages.front());
        _messages.pop_front();

        return msg;
    }

    void send(T &&msg)
    {
        std::lock_guard<std::mutex> ulock(_mutex);
        _messages.push_back(std::move(msg));
        _cond.notify_one();
    }

    size_t getSize()
    {
        return _messages.size();
    }
    
    int getTotal()
    {
        // if _total = 0, sending is unfinished
        // if _total > 0, the total number of messages being sent
        std::lock_guard<std::mutex> ulock(_mutex);
        return _total;
    }
    void setTotal(int total)
    {
        std::lock_guard<std::mutex> ulock(_mutex);
        _total = total;
    }
  //переменные управления потоками при выполнении кода
  private:
    std::mutex _mutex;
    std::condition_variable _cond;
    std::deque<T> _messages;
    int _total = 0;
};

#endif

//1. std::mutex _mutex
//
//std::mutex _mutex;
//Этот код создает объект _mutex типа std::mutex.Мьютекс(или взаимное исключение) используется для синхронизации 
// потоков выполнения программы.Он позволяет блокировать доступ к критическим секциям кода, 
// чтобы предотвратить одновременное выполнение одного участка кода несколькими потоками.
// Это важно для предотвращения состояния гонки(race condition) и других проблем, 
// возникающих при параллельной работе.
//
//Основные функции мьютекса :
//lock() : Блокирует мьютекс до тех пор, пока другой поток не вызовет unlock() или try_lock_for().
//unlock() : Освобождает мьютекс после завершения работы в критической секции.
//try_lock() : Пытается заблокировать мьютекс.Если мьютекс уже занят другим потоком, функция возвращает false.

//2. std::condition_variable _cond
//
// std::condition_variable _cond;
// Это создание объекта _cond типа std::condition_variable.Условная переменная(условие ожидания) 
// используется вместе с мьютексом для координации работы потоков.Она позволяет одному потоку ждать, 
// пока другой поток выполнит определенное условие(например, когда данные станут доступны).
//
//Основные функции условной переменной :
//wait(lock) : Поток засыпает, ожидая сигнала от другого потока.
// Пока поток спит, мьютекс разблокируется, чтобы другие потоки могли продолжить работу.
//notify_one() : Пробуждает один из спящих потоков, ожидающих на этой условной переменной.
//notify_all() : Пробуждает все потоки, ожидающие на этой условной переменной.

//3. std::deque<T> _messages
//
//std::deque<T> _messages;
//Создание объекта _messages типа std::deque<T>.Здесь T — шаблонный параметр, 
// который определяет тип элементов в деке.std::deque(дек) — это контейнер, 
// поддерживающий эффективное добавление / удаление элементов с обоих концов.
// В контексте многопоточного программирования это может использоваться как очередь сообщений или событий, 
// передаваемых между потоками.
//
//Основные методы deque :
//push_back(value) : Добавляет элемент в конец контейнера.
//pop_front() : Удаляет первый элемент из начала контейнера.
//front() : Возвращает ссылку на первый элемент.
//back() : Возвращает ссылку на последний элемент.
//Общая картина
//Объекты _mutex, _cond и _messages работают совместно для реализации безопасного обмена 
//сообщениями между потоками.Мьютекс _mutex обеспечивает защиту критической секции кода, 
//предотвращая одновременную модификацию данных разными потоками.
//Условная переменная _cond используется для уведомления потоков о наличии новых сообщений в очереди 
//_messages.Таким образом, один поток может добавлять элементы в очередь, 
//а другой поток будет ожидать поступления новых сообщений и обрабатывать их.